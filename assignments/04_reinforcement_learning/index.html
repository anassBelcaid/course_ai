<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Reinforcement Learning | Fundamentals of Artificial Intelligence </title> <meta name="author" content="Anass Dr. Belcaid"> <meta name="description" content="Assignement on Reinforcement learning"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/course_ai/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/course_ai/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/course_ai/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/course_ai/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/course_ai/assets/img/logo.jpg?bcb4c9013bcba3070632f31cd64d7e45"> <link rel="stylesheet" href="/course_ai/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://anassbelcaid.github.io/course_ai/assignments/04_reinforcement_learning/"> <script src="/course_ai/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/course_ai/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/course_ai/assets/js/distillpub/template.v2.js"></script> <script src="/course_ai/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Reinforcement Learning",
            "description": "Assignement on Reinforcement learning",
            "published": "April 26, 2025",
            "authors": [
              
              {
                "author": "Anass Belcaid",
                "authorURL": "https://anassbelcaid.github.io/",
                "affiliations": [
                  {
                    "name": "IAD, ENSA-Te",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/course_ai/"> Fundamentals of Artificial Intelligence </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/course_ai/">CS241 </a> </li> <li class="nav-item "> <a class="nav-link" href="/course_ai/lectures/">Schedule </a> </li> <li class="nav-item active"> <a class="nav-link" href="/course_ai/assignments/">Assignments <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/course_ai/projects/">projects </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Reinforcement Learning</h1> <p>Assignement on Reinforcement learning</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#introduction">Introduction</a> </div> <div> <a href="#mdps">MDPs</a> </div> <div> <a href="#value-iteration">Value Iteration</a> </div> <div> <a href="#policies">Policies</a> </div> <div> <a href="#q-learning">Q-learning</a> </div> <div> <a href="#epsilon-greedy">Epsilon Greedy</a> </div> <div> <a href="#q-learning-and-pacman">Q-Learning and Pacman</a> </div> <div> <a href="#approximate-q-learning">Approximate Q-Learning</a> </div> </nav> </d-contents> <center> <img src="https://anassbelcaid.github.io/course_ai/assets/img/capsule.png" alt="Girl in a jacket"> </center> <div class="caption"> Pacman seeks reward. Should he eat or should he run? When in doubt, Q-learn. </div> <h2 id="introduction">Introduction</h2> <p>In this project, you will implement value iteration and Q-learning. You will test your agents first on Gridworld (from class), then apply them to a simulated robot controller (Crawler) and Pacman.</p> <p>As in previous projects, this project includes an autograder for you to grade your solutions on your machine. This can be run on all questions with the command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py
</code></pre></div></div> <p>It can be run for one particular question, such as q2, by:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q2
</code></pre></div></div> <p>It can be run for one particular test by commands of the form:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -t test_cases/q2/1-bridge-grid
</code></pre></div></div> <p>The code for this project contains the following files, available as a <a href="/course_ai/assets/reinforcement.zip">zip archive</a></p> <h3 id="files-youll-edit">Files you’ll edit</h3> <table> <thead> <tr> <th style="text-align: left">File</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="/course_ai/path/to/valueIterationAgents.py">valueIterationAgents.py</a></td> <td style="text-align: left">A value iteration agent for solving known MDPs.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/qlearningAgents.py">qlearningAgents.py</a></td> <td style="text-align: left">Q-learning agents for Gridworld, Crawler and Pacman.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/analysis.py">analysis.py</a></td> <td style="text-align: left">A file to put your answers to questions given in the project.</td> </tr> </tbody> </table> <h3 id="files-you-might-want-to-look-at">Files you might want to look at</h3> <table> <thead> <tr> <th style="text-align: left">File</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="/course_ai/path/to/mdp.py">mdp.py</a></td> <td style="text-align: left">Defines methods on general MDPs.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/learningAgents.py">learningAgents.py</a></td> <td style="text-align: left">Defines the base classes <code class="language-plaintext highlighter-rouge">ValueEstimationAgent</code> and <code class="language-plaintext highlighter-rouge">QLearningAgent</code>, which your agents will extend.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/util.py">util.py</a></td> <td style="text-align: left">Utilities, including <code class="language-plaintext highlighter-rouge">util.Counter</code>, which is particularly useful for Q-learners.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/gridworld.py">gridworld.py</a></td> <td style="text-align: left">The Gridworld implementation.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/featureExtractors.py">featureExtractors.py</a></td> <td style="text-align: left">Classes for extracting features on (state, action) pairs. Used for the approximate Q-learning agent.</td> </tr> </tbody> </table> <h3 id="supporting-files-you-can-ignore">Supporting files you can ignore</h3> <table> <thead> <tr> <th style="text-align: left">File</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="/course_ai/path/to/environment.py">environment.py</a></td> <td style="text-align: left">Abstract class for general reinforcement learning environments. Used by <code class="language-plaintext highlighter-rouge">gridworld.py</code>.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/graphicsGridworldDisplay.py">graphicsGridworldDisplay.py</a></td> <td style="text-align: left">Gridworld graphical display.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/graphicsUtils.py">graphicsUtils.py</a></td> <td style="text-align: left">Graphics utilities.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/textGridworldDisplay.py">textGridworldDisplay.py</a></td> <td style="text-align: left">Plug-in for the Gridworld text interface.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/crawler.py">crawler.py</a></td> <td style="text-align: left">The crawler code and test harness. You will run this but not edit it.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/graphicsCrawlerDisplay.py">graphicsCrawlerDisplay.py</a></td> <td style="text-align: left">GUI for the crawler robot.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/autograder.py">autograder.py</a></td> <td style="text-align: left">Project autograder.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/testParser.py">testParser.py</a></td> <td style="text-align: left">Parses autograder test and solution files.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/testClasses.py">testClasses.py</a></td> <td style="text-align: left">General autograding test classes.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/test_cases/">test_cases/</a></td> <td style="text-align: left">Directory containing the test cases for each question.</td> </tr> <tr> <td style="text-align: left"><a href="/course_ai/path/to/reinforcementTestClasses.py">reinforcementTestClasses.py</a></td> <td style="text-align: left">Project 3 specific autograding test classes.</td> </tr> </tbody> </table> <h2 id="mdps">MDPs</h2> <p>To get started, run Gridworld in manual control mode, which uses the arrow keys:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -m
</code></pre></div></div> <p>You will see the two-exit layout from class. The blue dot is the agent. Note that when you press up, the agent only actually moves north 80% of the time. Such is the life of a Gridworld agent!</p> <p>You can control many aspects of the simulation. A full list of options is available by running:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -h
</code></pre></div></div> <p>The default agent moves randomly</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -g MazeGrid
</code></pre></div></div> <p>You should see the random agent bounce around the grid until it happens upon an exit. Not the finest hour for an AI agent.</p> <blockquote> <p>Note: The Gridworld MDP is such that you first must enter a pre-terminal state (the double boxes shown in the GUI) and then take the special ‘exit’ action before the episode actually ends (in the true terminal state called <code class="language-plaintext highlighter-rouge">TERMINAL_STATE</code>, which is not shown in the GUI). If you run an episode manually, your total return may be less than you expected, due to the discount rate (-d to change; 0.9 by default).</p> </blockquote> <p>Look at the console output that accompanies the graphical output (or use -t for all text). You will be told about each transition the agent experiences (to turn this off, use -q).</p> <p>As in Pacman, positions are represented by $(x, y)$ Cartesian coordinates and any arrays are indexed by [x][y], with ‘north’ being the direction of increasing y, etc. By default, most transitions will receive a reward of zero, though you can change this with the living reward option (-r).</p> <h2 id="value-iteration">Value Iteration</h2> <p>Recall the value iteration state update equation:</p> \[V_{k+1}(s) \leftarrow \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V_k(s') \right]\] <p>Write a value iteration agent in <code class="language-plaintext highlighter-rouge">ValueIterationAgent</code>, which has been partially specified for you in <a href="/course_ai/path/to/valueIterationAgents.py">valueIterationAgents.py</a>.</p> <p>Your value iteration agent is an <strong>offline planner</strong>, not a reinforcement learning agent, and so the relevant training option is the number of iterations of value iteration it should run (<code class="language-plaintext highlighter-rouge">-i</code>) during its initial planning phase.</p> <p><code class="language-plaintext highlighter-rouge">ValueIterationAgent</code> takes an MDP on construction and runs value iteration for the specified number of iterations before the constructor returns.</p> <p>Value iteration computes (k)-step estimates of the optimal values, $V_k$.<br> In addition to <code class="language-plaintext highlighter-rouge">runValueIteration</code>, implement the following methods for <code class="language-plaintext highlighter-rouge">ValueIterationAgent</code> using $V_k$:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">computeActionFromValues(state)</code> — computes the best action according to the value function given by <code class="language-plaintext highlighter-rouge">self.values</code>.</li> <li> <code class="language-plaintext highlighter-rouge">computeQValueFromValues(state, action)</code> — returns the Q-value of the (state, action) pair given by the value function given by <code class="language-plaintext highlighter-rouge">self.values</code>.</li> </ul> <p>These quantities are displayed in the GUI:</p> <ul> <li> <strong>Values</strong> are numbers in squares,</li> <li> <strong>Q-values</strong> are numbers in square quarters,</li> <li> <strong>Policies</strong> are arrows pointing out from each square.</li> </ul> <h3 id="important-notes">Important Notes</h3> <ul> <li> <p><strong>Batch Value Iteration</strong>:<br> Use the “batch” version where each vector $V_k$ is computed from a fixed vector $V_{k-1}$ (like in lecture), not the “online” version where a single weight vector is updated in place.<br> This means when updating a state’s value during iteration $k$, always use the values from iteration $k-1$, even if some successor states were already updated in iteration $k$.</p> </li> <li> <p>This distinction is discussed in <strong>Sutton &amp; Barto</strong>, Chapter 4.1 (page 91).</p> </li> <li> <p><strong>Policy Depth</strong>:<br> A policy synthesized from values of depth $k$ will reflect the next $k+1$ rewards (i.e., you return $\pi_{k+1}$), and the Q-values will similarly reflect one more reward than the values.</p> </li> <li> <p><strong>Hint</strong>:<br> You may optionally use the <code class="language-plaintext highlighter-rouge">util.Counter</code> class from <a href="/course_ai/path/to/util.py">util.py</a>, which is a dictionary with default value 0.<br> Be careful with <code class="language-plaintext highlighter-rouge">argMax</code>: the actual best key may not be explicitly stored if its value is zero.</p> </li> <li> <p><strong>No Available Actions</strong>:<br> Make sure to correctly handle states with <strong>no available actions</strong> (think about what this means for future rewards).</p> </li> </ul> <p>To test your implementation, run the autograder:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q1
</code></pre></div></div> <p>The following command loads your ValueIterationAgent, which will compute a policy and execute it 10 times. Press a key to cycle through values, Q-values, and the simulation. You should find that the value of the start state (V(start), which you can read off of the GUI) and the empirical resulting average reward (printed after the 10 rounds of execution finish) are quite close.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a value -i 100 -k 10
</code></pre></div></div> <blockquote> <p>Hint: On the default BookGrid, running value iteration for 5 iterations should give you this output:</p> </blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a value -i 5
</code></pre></div></div> <center> <img src="https://anassbelcaid.github.io/course_ai/assets/img/value_iter_diagram.png" alt="Girl in a jacket"> </center> <h2 id="policies">Policies</h2> <p>Consider the DiscountGrid layout, shown below. This grid has two terminal states with positive payoff (in the middle row), a close exit with payoff +1 and a distant exit with payoff +10. The bottom row of the grid consists of terminal states with negative payoff (shown in red); each state in this “cliff” region has payoff -10. The starting state is the yellow square. We distinguish between two types of paths: (1) paths that “risk the cliff” and travel near the bottom row of the grid; these paths are shorter but risk earning a large negative payoff, and are represented by the red arrow in the figure below. (2) paths that “avoid the cliff” and travel along the top edge of the grid. These paths are longer but are less likely to incur huge negative payoffs. These paths are represented by the green arrow in the figure below.</p> <center> <img src="https://anassbelcaid.github.io/course_ai/assets/img/value_2_paths.png" width="400" height="400" alt="Girl in a jacket"> </center> <p>In this question, you will choose settings of the discount, noise, and living reward parameters for this MDP to produce optimal policies of several different types. <strong>Your setting of the parameter values for each part should have the property that, if your agent followed its optimal policy without being subject to any noise, it would exhibit the given behavior</strong>. If a particular behavior is not achieved for any setting of the parameters, assert that the policy is impossible by returning the string ‘NOT POSSIBLE’.</p> <p>Here are the optimal policy types you should attempt to produce:</p> <ul> <li>Prefer the close exit (+1), risking the cliff (-10)</li> <li>Prefer the close exit (+1), but avoiding the cliff (-10)</li> <li>Prefer the distant exit (+10), risking the cliff (-10)</li> <li>Prefer the distant exit (+10), avoiding the cliff (-10)</li> <li>Avoid both exits and the cliff (so an episode should never terminate)</li> <li>To see what behavior a set of numbers ends up in, run the following command to see a GUI:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -g DiscountGrid -a value --discount [YOUR_DISCOUNT] --noise [YOUR_NOISE] --livingReward [YOUR_LIVING_REWARD]
</code></pre></div></div> <p>To check your answers, run the autograder:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q2
</code></pre></div></div> <h2 id="q-learning">Q-Learning</h2> <p>Note that your value iteration agent does <strong>not</strong> actually learn from experience.<br> Rather, it <strong>ponders its MDP model</strong> to arrive at a complete policy before ever interacting with a real environment.<br> When it does interact with the environment, it simply follows the precomputed policy (e.g., it becomes a reflex agent).<br> This distinction may be subtle in a simulated environment like Gridworld, but it’s <strong>very important in the real world</strong>, where the real MDP is <strong>not available</strong>.</p> <p>You will now write a <strong>Q-learning agent</strong>, which does very little on construction but instead <strong>learns by trial and error</strong> from interactions with the environment through its <code class="language-plaintext highlighter-rouge">update(state, action, nextState, reward)</code> method.</p> <p>A stub of a Q-learner is provided in <a href="/course_ai/path/to/qlearningAgents.py">QLearningAgent</a>, and you can select it with the option <code class="language-plaintext highlighter-rouge">-a q</code>.</p> <p>For this question, you must implement the following methods:</p> <ul> <li><code class="language-plaintext highlighter-rouge">update</code></li> <li><code class="language-plaintext highlighter-rouge">computeValueFromQValues</code></li> <li><code class="language-plaintext highlighter-rouge">getQValue</code></li> <li><code class="language-plaintext highlighter-rouge">computeActionFromQValues</code></li> </ul> <h3 id="important-notes-1">Important Notes</h3> <ul> <li> <p><strong>Random Tie-Breaking</strong>:<br> For <code class="language-plaintext highlighter-rouge">computeActionFromQValues</code>, you should <strong>break ties randomly</strong> for better behavior.<br> The <code class="language-plaintext highlighter-rouge">random.choice()</code> function will help.</p> </li> <li> <p><strong>Unseen Actions</strong>:<br> In any state, actions your agent hasn’t seen before still have a Q-value (specifically, <strong>zero</strong>).<br> If all known actions have negative Q-values, an unseen action may be optimal.</p> </li> <li> <p><strong>Access Q-Values Correctly</strong>:<br> In both <code class="language-plaintext highlighter-rouge">computeValueFromQValues</code> and <code class="language-plaintext highlighter-rouge">computeActionFromQValues</code>, <strong>only access Q-values by calling <code class="language-plaintext highlighter-rouge">getQValue</code></strong>.<br> This abstraction will be useful later (e.g., for Question 10 when you override <code class="language-plaintext highlighter-rouge">getQValue</code> to use features).</p> </li> </ul> <p>With the Q-learning update in place, you can watch your Q-learner learn under manual control, using the keyboard:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a q -k 5 -m
</code></pre></div></div> <p>Recall that -k will control the number of episodes your agent gets to learn. Watch how the agent learns about the state it was just in, not the one it moves to, and “leaves learning in its wake.” Hint: to help with debugging, you can turn off noise by using the –noise 0.0 parameter (though this obviously makes Q-learning less interesting). If you manually steer Pacman north and then east along the optimal path for four episodes, you should see the following Q-values:</p> <center> <img src="https://anassbelcaid.github.io/course_ai/assets/img/q_learning.png" width="400" height="400" alt="Girl in a jacket"> </center> <p>Finally to check your code run the autograder on question 3.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q3
</code></pre></div></div> <h2 id="epsilon-greedy">Epsilon Greedy</h2> <p>Complete your Q-learning agent by implementing epsilon-greedy action selection in <code class="language-plaintext highlighter-rouge">getAction</code>, meaning it chooses random actions an epsilon fraction of the time, and follows its current best Q-values otherwise. Note that choosing a random action may result in choosing the best action - that is, you should not choose a random sub-optimal action, but rather any random legal action.</p> <p>You can choose an element from a list uniformly at random by calling the <code class="language-plaintext highlighter-rouge">random.choice</code> function. You can simulate a binary variable with probability p of success by using <code class="language-plaintext highlighter-rouge">util.flipCoin(p)</code>, which returns True with probability $p$ and False with probability $1-p$.</p> <p>After implementing the getAction method, observe the following behavior of the agent in GridWorld (with epsilon = 0.3).</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a q -k 100
</code></pre></div></div> <p>Your final Q-values should resemble those of your value iteration agent, especially along well-traveled paths. However, your average returns will be lower than the Q-values predict because of the random actions and the initial learning phase.</p> <p>You can also observe the following simulations for different epsilon values. Does that behavior of the agent match what you expect?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a q -k 100 --noise 0.0 -e 0.1
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python gridworld.py -a q -k 100 --noise 0.0 -e 0.9
</code></pre></div></div> <p>To test your implementation, run the autograder:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q4
</code></pre></div></div> <p>With no additional code, you should now be able to run a Q-learning crawler robot:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python crawler.py
</code></pre></div></div> <p>If this doesn’t work, you’ve probably written some code too specific to the GridWorld problem and you should make it more general to all MDPs.</p> <p>This will invoke the crawling robot from class using your Q-learner. Play around with the various learning parameters to see how they affect the agent’s policies and actions. Note that the step delay is a parameter of the simulation, whereas the learning rate and epsilon are parameters of your learning algorithm, and the discount factor is a property of the environment.</p> <h2 id="q-learning-and-pacman">Q-Learning and Pacman</h2> <p>Time to play some Pacman! Pacman will play games in two phases. In the first phase, training, Pacman will begin to learn about the values of positions and actions. Because it takes a very long time to learn accurate Q-values even for tiny grids, Pacman’s training games run in quiet mode by default, with no GUI (or console) display. Once Pacman’s training is complete, he will enter testing mode. When testing, Pacman’s <code class="language-plaintext highlighter-rouge">self.epsilon</code> and <code class="language-plaintext highlighter-rouge">self.alpha</code> will be set to 0.0, effectively stopping Q-learning and disabling exploration, in order to allow Pacman to exploit his learned policy. Test games are shown in the GUI by default. Without any code changes you should be able to run Q-learning Pacman for very tiny grids as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python pacman.py -p PacmanQAgent -x 2000 -n 2010 -l smallGrid
</code></pre></div></div> <p>Note that PacmanQAgent is already defined for you in terms of the QLearningAgent you’ve already written. PacmanQAgent is only different in that it has default learning parameters that are more effective for the Pacman problem <code class="language-plaintext highlighter-rouge">(epsilon=0.05, alpha=0.2, gamma=0.8)</code>. You will receive full credit for this question if the command above works without exceptions and your agent wins at least 80% of the time. The autograder will run 100 test games after the 2000 training games.</p> <p><strong>Hint</strong>: If your QLearningAgent works for gridworld.py and crawler.py but does not seem to be learning a good policy for Pacman on smallGrid, it may be because your getAction and/or computeActionFromQValues methods do not in some cases properly consider unseen actions. In particular, because unseen actions have by definition a Q-value of zero, if all of the actions that have been seen have negative Q-values, an unseen action may be optimal. Beware of the argMax function from util.Counter!</p> <p>To grade your answer, run:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder -q q5
</code></pre></div></div> <p>Note: If you want to experiment with learning parameters, you can use the option -a, for example <code class="language-plaintext highlighter-rouge">-a epsilon=0.1,alpha=0.3,gamma=0.7</code>. These values will then be accessible as <code class="language-plaintext highlighter-rouge">self.epsilon</code>, <code class="language-plaintext highlighter-rouge">self.gamma</code> and <code class="language-plaintext highlighter-rouge">self.alpha</code> inside the agent.</p> <p>Note: While a total of 2010 games will be played, the first 2000 games will not be displayed because of the option <code class="language-plaintext highlighter-rouge">-x 2000</code>, which designates the first 2000 games for training (no output). Thus, you will only see Pacman play the last 10 of these games. The number of training games is also passed to your agent as the option <code class="language-plaintext highlighter-rouge">numTraining</code>.</p> <p>Note: If you want to watch 10 training games to see what’s going on, use the command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python pacman.py -p PacmanQAgent -n 10 -l smallGrid -a numTraining=10
</code></pre></div></div> <p>During training, you will see output every 100 games with statistics about how Pacman is faring. Epsilon is positive during training, so Pacman will play poorly even after having learned a good policy: this is because he occasionally makes a random exploratory move into a ghost. As a benchmark, it should take between 1000 and 1400 games before Pacman’s rewards for a 100 episode segment becomes positive, reflecting that he’s started winning more than losing. By the end of training, it should remain positive and be fairly high (between 100 and 350).</p> <p>Make sure you understand what is happening here: the MDP state is the exact board configuration facing Pacman, with the now complex transitions describing an entire ply of change to that state. The intermediate game configurations in which Pacman has moved but the ghosts have not replied are not MDP states, but are bundled in to the transitions.</p> <p>Once Pacman is done training, he should win very reliably in test games (at least 90% of the time), since now he is exploiting his learned policy.</p> <p>However, you will find that training the same agent on the seemingly simple mediumGrid does not work well. In our implementation, Pacman’s average training rewards remain negative throughout training. At test time, he plays badly, probably losing all of his test games. Training will also take a long time, despite its ineffectiveness.</p> <p>Pacman fails to win on larger layouts because each board configuration is a separate state with separate Q-values. He has no way to generalize that running into a ghost is bad for all positions. Obviously, this approach will not scale.</p> <h2 id="approximate-q-learning">Approximate Q-Learning</h2> <p>Implement an approximate Q-learning agent that learns weights for features of states, where many states might share the same features. Write your implementation in <code class="language-plaintext highlighter-rouge">ApproximateQAgent</code> class in <code class="language-plaintext highlighter-rouge">qlearningAgents.py</code>, which is a subclass of <code class="language-plaintext highlighter-rouge">PacmanQAgent</code>.</p> <p><em>Note</em>: Approximate Q-learning assumes the existence of a feature function $f(s,a)$ over state and action pairs, which yields a vector $[f_1(s,a),\ldots,f_i(s,a),\ldots,f_n(s,a)]$ of feature values. We provide feature functions for you in <code class="language-plaintext highlighter-rouge">featureExtractors.py</code>. Feature vectors are <code class="language-plaintext highlighter-rouge">util.Counter</code> (like a dictionary) objects containing the non-zero pairs of features and values; all omitted features have value zero. So, instead of an vector where the index in the vector defines which feature is which, we have the keys in the dictionary define the idenity of the feature.</p> <p>The approximate Q-function takes the following form:</p> \[Q(s,a)=\sum_{i=1}^n f_i(s,a) w_i\] <p>where each weight $w_i$ is associated with a particular feature $f_i(s,a)$. In your code, you should implement the weight vector as a dictionary mapping features (which the feature extractors will return) to weight values. You will update your weight vectors similarly to how you updated Q-values:</p> \[w_i \leftarrow w_i + \alpha \cdot \text{difference} \cdot f_i(s,a)\] \[\text{difference} = (r + \gamma \max_{a'} Q(s', a')) - Q(s,a)\] <p>Note that the $\text{difference}$ term is the same as in normal Q-learning, and $r$ is the experienced reward.</p> <p>By default, <code class="language-plaintext highlighter-rouge">ApproximateQAgent</code> uses the <code class="language-plaintext highlighter-rouge">IdentityExtractor</code>, which assigns a single feature to every <code class="language-plaintext highlighter-rouge">(state,action)</code> pair. With this feature extractor, your approximate Q-learning agent should work identically to <code class="language-plaintext highlighter-rouge">PacmanQAgent</code>. You can test this with the following command:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python pacman.py -p ApproximateQAgent -x 2000 -n 2010 -l smallGrid
</code></pre></div></div> <p><strong>Important</strong>: <code class="language-plaintext highlighter-rouge">ApproximateQAgent</code> is a subclass of QLearningAgent, and it therefore shares several methods like getAction. Make sure that your methods in QLearningAgent call getQValue instead of accessing Q-values directly, so that when you override <code class="language-plaintext highlighter-rouge">getQValue</code> in your approximate agent, the new approximate q-values are used to compute actions.</p> <p>Once you’re confident that your approximate learner works correctly with the identity features, run your approximate Q-learning agent with our custom feature extractor, which can learn to win with ease:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python pacman.py -p ApproximateQAgent -a extractor=SimpleExtractor -x 50 -n 60 -l mediumGrid
</code></pre></div></div> <p>Even much larger layouts should be no problem for your <code class="language-plaintext highlighter-rouge">ApproximateQAgent</code> (warning: this may take a few minutes to train):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python pacman.py -p ApproximateQAgent -a extractor=SimpleExtractor -x 50 -n 60 -l mediumClassic
</code></pre></div></div> <p>If you have no errors, your approximate Q-learning agent should win almost every time with these simple features, even with only 50 training games.</p> <p>To test your code.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python autograder.py -q q6
</code></pre></div></div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/course_ai/assets/bibliography/2018-12-22-distill.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'anassBelcaid/course_ai',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Anass Dr. Belcaid. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/mermaid-setup.js?38ca0a0126f7328d2d9a46bad640931f" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/diff2html-setup.js?80a6e52ce727518bbd3aed2bb6ba5601" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/leaflet-setup.js?b6313931e203b924523e2d8b75fe8874" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/course_ai/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/course_ai/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/course_ai/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/course_ai/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/course_ai/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>
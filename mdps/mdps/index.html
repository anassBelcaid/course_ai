<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Markov Decision Processes | Fundamentals of Artificial Intelligence </title> <meta name="author" content="Anass Dr. Belcaid"> <meta name="description" content="Markov Decision Processes"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/course_ai/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/course_ai/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/course_ai/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/course_ai/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/course_ai/assets/img/logo.jpg?bcb4c9013bcba3070632f31cd64d7e45"> <link rel="stylesheet" href="/course_ai/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://anassbelcaid.github.io/course_ai/mdps/mdps/"> <script src="/course_ai/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/course_ai/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script src="/course_ai/assets/js/distillpub/template.v2.js"></script> <script src="/course_ai/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Markov Decision Processes",
            "description": "Markov Decision Processes",
            "published": "April 01, 2025",
            "authors": [
              
              {
                "author": "Anass Belcaid",
                "authorURL": "https://anassbelcaid.github.io/",
                "affiliations": [
                  {
                    "name": "IAD, ENSA-Te",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/course_ai/"> Fundamentals of Artificial Intelligence </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/course_ai/">CS241 </a> </li> <li class="nav-item "> <a class="nav-link" href="/course_ai/lectures/">Schedule </a> </li> <li class="nav-item "> <a class="nav-link" href="/course_ai/assignments/">Assignments </a> </li> <li class="nav-item "> <a class="nav-link" href="/course_ai/projects/">projects </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Markov Decision Processes</h1> <p>Markov Decision Processes</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#markov-decision-processes">Markov Decision Processes</a> </div> <ul> <li> <a href="#finite-horizons-and-discounting">Finite Horizons and Discounting</a> </li> <li> <a href="#markovianess">Markovianess</a> </li> </ul> <div> <a href="#solving-markov-decision-processes">Solving Markov Decision Processes</a> </div> <ul> <li> <a href="#the-bellman-equation">The Bellman Equation</a> </li> </ul> <div> <a href="#value-iteration">Value Iteration</a> </div> <ul> <li> <a href="#policy-extraction">Policy Extraction</a> </li> <li> <a href="#q-value-iteration">Q-Value Iteration</a> </li> </ul> <div> <a href="#policy-iteration">Policy Iteration</a> </div> <div> <a href="#summary">Summary</a> </div> </nav> </d-contents> <h2 id="markov-decision-processes">Markov Decision Processes</h2> <p>A <strong>Markov Decision Process (MDP)</strong> is defined by several properties:</p> <ul> <li>A set of states $S$. States in MDPs are represented in the same way as states in traditional search problems.</li> <li>A set of actions $A$. Actions in MDPs are also represented in the same way as in traditional search problems.</li> <li>A start state.</li> <li>Possibly one or more terminal states.</li> <li>Possibly a <strong>discount factor</strong> $\gamma$. We’ll cover discount factors shortly.</li> <li>A <strong>transition function</strong> $T(s, a, s’)$. Since we have introduced the possibility of nondeterministic actions, we need a way to delineate the likelihood of the possible outcomes after taking any given action from any given state. The transition function for an MDP does exactly this—it’s a probability function that represents the probability that an agent taking an action $a \in A$ from a state $s \in S$ ends up in a state $s’ \in S$.</li> <li>A <strong>reward function</strong> $R(s, a, s’)$. Typically, MDPs are modeled with small “living” rewards at each step to reward an agent’s survival, along with large rewards for arriving at a terminal state. Rewards may be positive or negative depending on whether or not they benefit the agent in question, and the agent’s objective is naturally to acquire the maximum reward possible before arriving at some terminal state.</li> </ul> <p>Constructing an MDP for a situation is quite similar to constructing a state-space graph for a search problem, with a couple additional caveats. Consider the motivating example of a racecar:</p> <center> <img src="https://anassbelcaid.github.io/course_ai/mdps/race-car.png" width="500" height="300" alt="Girl in a jacket"> </center> <p>There are three possible states, $S = \{\text{cool}, \text{warm}, \text{overheated}\}$, and two possible actions $A = \{\text{slow}, \text{fast}\}$.</p> <p>Just like in a state-space graph, each of the three states is represented by a node, with edges representing actions. <strong>Overheated</strong> is a terminal state, since once a racecar agent arrives at this state, it can no longer perform any actions for further rewards (it’s a sink state in the MDP and has no outgoing edges).</p> <p>Notably, for nondeterministic actions, there are multiple edges representing the same action from the same state with differing successor states. Each edge is annotated not only with the action it represents but also with a transition probability and corresponding reward. These are summarized below:</p> <h3 id="transition-function">Transition Function:</h3> <p>$T(s, a, s’)$</p> \[T(\text{cool}, \text{slow}, \text{cool}) = 1\] \[T(\text{warm}, \text{slow}, \text{cool}) = 0.5\] \[T(\text{warm}, \text{slow}, \text{warm}) = 0.5\] \[T(\text{cool}, \text{fast}, \text{cool}) = 0.5\] \[T(\text{cool}, \text{fast}, \text{warm}) = 0.5\] \[T(\text{warm}, \text{fast}, \text{overheated}) = 1\] <h3 id="reward-function">Reward Function:</h3> <p>$R(s, a, s’)$</p> \[R(\text{cool}, \text{slow}, \text{cool}) = 1\] \[R(\text{warm}, \text{slow}, \text{cool}) = 1\] \[R(\text{warm}, \text{slow}, \text{warm}) = 1\] \[R(\text{cool}, \text{fast}, \text{cool}) = 2\] \[R(\text{cool}, \text{fast}, \text{warm}) = 2\] \[R(\text{warm}, \text{fast}, \text{overheated}) = -10\] <p>We represent the movement of an agent through different MDP states over time with discrete <strong>timesteps</strong>, defining $s_t \in S$ and $a_t \in A$ as the state in which an agent exists and the action which an agent takes at timestep $t$, respectively.</p> <p>An agent starts in state $s_0$ at timestep 0 and takes an action at every timestep. The movement of an agent through an MDP can thus be modeled as follows:</p> \[s_0 \xrightarrow{a_0} s_1 \xrightarrow{a_1} s_2 \xrightarrow{a_2} s_3 \xrightarrow{a_3} \dots\] <p>Additionally, knowing that an agent’s goal is to maximize its reward across all timesteps, we can correspondingly express this mathematically as a maximization of the following utility function:</p> \[U([s_0, a_0, s_1, a_1, s_2, \dots]) = R(s_0, a_0, s_1) + R(s_1, a_1, s_2) + R(s_2, a_2, s_3) + \dots\] <p>Markov decision processes, like state-space graphs, can be unraveled into search trees. Uncertainty is modeled in these search trees with Q-states, also known as action states, essentially identical to expectimax chance nodes. This is a fitting choice, as Q-states use probabilities to model the uncertainty that the environment will land an agent in a given state just as expectimax chance nodes use probabilities to model the uncertainty that adversarial agents will land our agent in a given state through the move these agents select. The Q-state represented by having taken action $a$ from state $s$ is notated as the tuple $(s,a)$.</p> <p>Observe the unraveled search tree for our racecar, truncated to depth-2:</p> <center> <img src="https://anassbelcaid.github.io/course_ai/mdps/rc-search-tree.png" width="800" height="300" alt="Girl in a jacket"> </center> <p>The green nodes represent Q-states, where an action has been taken from a state but has yet to be resolved into a successor state. It’s important to understand that agents spend zero timesteps in Q-states, and that they are simply a construct created for ease of representation and development of MDP algorithms.</p> <h3 id="finite-horizons-and-discounting">Finite Horizons and Discounting</h3> <p>There is an inherent problem with our racecar MDP—we haven’t placed any time constraints on the number of timesteps for which a racecar can take actions and collect rewards. With our current formulation, it could routinely choose $a = \text{slow}$ at every timestep forever, safely and effectively obtaining infinite reward without any risk of overheating.</p> <p>This is prevented by the introduction of <strong>finite horizons</strong> and/or <strong>discount factors</strong>.</p> <p>An MDP enforcing a <strong>finite horizon</strong> is simple—it essentially defines a “lifetime” for agents, which gives them some set number of timesteps $n$ to accrue as much reward as they can before being automatically terminated. We’ll return to this concept shortly.</p> <p><strong>Discount factors</strong> are slightly more complicated and are introduced to model an exponential decay in the value of rewards over time. Concretely, with a discount factor of $\gamma$, taking action $a_t$ from state $s_t$ at timestep $t$ and ending up in state $s_{t+1}$ results in a reward of</p> \[\gamma^t R(s_t, a_t, s_{t+1})\] <p>instead of just $R(s_t, a_t, s_{t+1})$.</p> <p>Now, instead of maximizing the <strong>additive utility</strong></p> \[U([s_0, a_0, s_1, a_1, s_2, \dots]) = R(s_0, a_0, s_1) + R(s_1, a_1, s_2) + R(s_2, a_2, s_3) + \dots\] <p>we attempt to maximize the <strong>discounted utility</strong></p> \[U([s_0, a_0, s_1, a_1, s_2, \dots]) = R(s_0, a_0, s_1) + \gamma R(s_1, a_1, s_2) + \gamma^2 R(s_2, a_2, s_3) + \dots\] <p>Noting that the above definition of a discounted utility function looks similar to a geometric series with ratio $\gamma$, we can prove that it’s guaranteed to be finite-valued as long as the constraint</p> \[|\gamma| &lt; 1\] <p>where $\vert n\vert$ denotes the absolute value operator) is met through the following logic:</p> \[U([s_0, s_1, s_2, \dots]) = R(s_0, a_0, s_1) + \gamma R(s_1, a_1, s_2) + \gamma^2 R(s_2, a_2, s_3) + \dots\] \[= \sum_{t=0}^{\infty} \gamma^t R(s_t, a_t, s_{t+1}) \leq \sum_{t=0}^{\infty} \gamma^t R_{\max} = \frac{R_{\max}}{1 - \gamma}\] <p>where $R_{\max}$ is the maximum possible reward attainable at any given timestep in the MDP.</p> <p>Typically, $\gamma$ is selected strictly from the range $0 &lt; \gamma &lt; 1$ since values in the range $-1 &lt; \gamma \leq 0$ are simply not meaningful in most real-world situations—a negative value for $\gamma$ means the reward for a state $s$ would flip-flop between positive and negative values at alternating timesteps.</p> <h3 id="markovianess">Markovianess</h3> <p>Markov decision processes are “Markovian” in the sense that they satisfy the <strong>Markov property</strong>, or <strong>memoryless property</strong>, which states that the future and the past are conditionally independent, given the present.</p> <p>Intuitively, this means that, if we know the present state, knowing the past doesn’t give us any more information about the future. To express this mathematically, consider an agent that has visited states</p> \[s_0, s_1, \dots, s_t\] <p>after taking actions</p> \[a_0, a_1, \dots, a_{t-1}\] <p>in some MDP, and has just taken action $a_t$. The probability that this agent then arrives at state $s_{t+1}$ given their history of previous states visited and actions taken can be written as follows:</p> \[P(S_{t+1} = s_{t+1} \mid S_t = s_t, A_t = a_t, S_{t-1} = s_{t-1}, A_{t-1} = a_{t-1}, \dots, S_0 = s_0)\] <p>where each $S_t$ denotes the random variable representing our agent’s state and $A_t$ denotes the random variable representing the action our agent takes at time $t$.</p> <p>The Markov property states that the above probability can be simplified as follows:</p> \[P(S_{t+1} = s_{t+1} \mid S_t = s_t, A_t = a_t, S_{t-1} = s_{t-1}, A_{t-1} = a_{t-1}, \dots, S_0 = s_0) = P(S_{t+1} = s_{t+1} \mid S_t = s_t, A_t = a_t)\] <p>which is <code class="language-plaintext highlighter-rouge">memoryless</code> in the sense that the probability of arriving in a state $s’$ at time $t+1$ depends only on the state $s$ and action $a$ taken at time $t$, not on any earlier states or actions.</p> <p>In fact, it is these memoryless probabilities that are encoded by the transition function:</p> \[T(s, a, s') = P(s' \mid s, a)\] <h2 id="solving-markov-decision-processes">Solving Markov Decision Processes</h2> <p>Recall that in <strong>deterministic, non-adversarial search</strong>, solving a search problem means finding an optimal plan to arrive at a goal state.</p> <p>Solving a <strong>Markov decision process</strong>, on the other hand, means finding an <strong>optimal policy</strong></p> \[\pi^*: S \to A\] <p>a function mapping each state $s \in S$ to an action $a \in A$.</p> <p>An explicit policy $\pi$ defines a <strong>reflex agent</strong>—given a state $s$, an agent at $s$ implementing $\pi$ will select</p> \[a = \pi(s)\] <p>as the appropriate action to take <strong>without considering future consequences</strong> of its actions.</p> <p>An <strong>optimal policy</strong> is one that, if followed by the implementing agent, will yield the <strong>maximum expected total reward or utility</strong>.</p> <p>Consider the following <strong>MDP</strong> with:</p> <ul> <li> <strong>State set</strong>: $S = \{a, b, c, d, e\}$</li> <li> <strong>Action set</strong>: $A = \{\text{East}, \text{West}, \text{Exit}\}$ <ul> <li>(with <strong>Exit</strong> being a valid action only in states $a$ and $e$, yielding rewards of <strong>10</strong> and <strong>1</strong> respectively)</li> </ul> </li> <li> <strong>Discount factor</strong>: $\gamma = 0.1$</li> <li><strong>Deterministic transitions</strong></li> </ul> <center> <img src="https://anassbelcaid.github.io/course_ai/mdps/easy-mdp.png" width="500" height="150" alt="Girl in a jacket"> </center> <p>Two potential policies for this MDP are as follows:</p> <table> <thead> <tr> <th style="text-align: center"><img src="https://anassbelcaid.github.io/course_ai/mdps/policy-1.png" width="250"></th> <th style="text-align: center"><img src="https://anassbelcaid.github.io/course_ai/mdps/policy-2.png" width="250"></th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><strong>Policy 1</strong></td> <td style="text-align: center"><strong>Policy 2</strong></td> </tr> </tbody> </table> <p>With some investigation, it’s not hard to determine that <strong>Policy 2</strong> is optimal. Following the policy until making action $a = \text{Exit}$ yields the following rewards for each start state:</p> <table> <thead> <tr> <th style="text-align: center"><strong>Start State</strong></th> <th style="text-align: center"><strong>Reward</strong></th> </tr> </thead> <tbody> <tr> <td style="text-align: center">a</td> <td style="text-align: center">10</td> </tr> <tr> <td style="text-align: center">b</td> <td style="text-align: center">1</td> </tr> <tr> <td style="text-align: center">c</td> <td style="text-align: center">0.1</td> </tr> <tr> <td style="text-align: center">d</td> <td style="text-align: center">0.1</td> </tr> <tr> <td style="text-align: center">e</td> <td style="text-align: center">1</td> </tr> </tbody> </table> <p>We’ll now learn how to solve such MDPs (and much more complex ones!) algorithmically using the <strong>Bellman equation</strong> for Markov decision processes.</p> <h3 id="the-bellman-equation">The Bellman Equation</h3> <p>In order to talk about the Bellman equation for MDPs, we must first introduce two new mathematical quantities:</p> <ul> <li>The <strong>optimal value of a state</strong> $s$, $V^{\star}(s)$ — the optimal value of $s$ is the expected value of the utility an optimally-behaving agent that starts in $s$ will receive, over the rest of the agent’s lifetime. Note that frequently in the literature the same quantity is denoted with $V^*(s)$.</li> <li>The <strong>optimal value of a Q-state</strong> $(s, a)$, $Q^*(s, a)$ — the optimal value of $(s, a)$ is the expected value of the utility an agent receives after starting in $s$, taking $a$, and acting optimally henceforth.</li> </ul> <p>Using these two new quantities and the other MDP quantities discussed earlier, the <strong>Bellman equation</strong> is defined as follows:</p> \[V^*(s) = \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V^*(s') \right]\] <p>Before we begin interpreting what this means, let’s also define the equation for the optimal value of a Q-state (more commonly known as an <strong>optimal Q-value</strong>):</p> \[Q^*(s, a) = \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V^*(s') \right]\] <p>Note that this second definition allows us to re-express the Bellman equation as:</p> \[V^*(s) = \max_a Q^*(s, a)\] <p>which is a dramatically simpler quantity. The Bellman equation is an example of a <strong>dynamic programming equation</strong>, an equation that decomposes a problem into smaller subproblems via an inherent recursive structure. We can see this inherent recursion in the equation for the Q-value of a state, in the term:</p> \[\left[ R(s, a, s') + \gamma V^*(s') \right]\] <p>This term represents the total utility an agent receives by first taking $a$ from $s$ and arriving at $s’$ and then acting optimally henceforth. The immediate reward from the action $a$ taken, $R(s, a, s’)$, is added to the optimal discounted sum of rewards attainable from $s’$, $V^{\star}(s’)$, which is discounted by $\gamma$ to account for the passage of one timestep in taking action $a$. Though in most cases there exists a vast number of possible sequences of states and actions from $s’$ to some terminal state, all this detail is abstracted away and encapsulated in a single recursive value, $V^*(s’)$.</p> <p>We can now take another step outwards and consider the full equation for Q-value. Knowing that:</p> \[\left[ R(s, a, s') + \gamma V^*(s') \right]\] <p>represents the utility attained by acting optimally after arriving in state $s’$ from Q-state $(s, a)$, it becomes evident that the quantity:</p> \[\sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V^*(s') \right]\] <p>is simply a <strong>weighted sum</strong> of utilities, with each utility weighted by its probability of occurrence. This is by definition the <strong>expected utility</strong> of acting optimally from Q-state $(s, a)$ onwards! This completes our analysis and gives us enough insight to interpret the full Bellman equation — the <strong>optimal value of a state</strong>, $V^*(s)$, is simply the maximum expected utility over all possible actions from $s$. Computing maximum expected utility for a state $s$ is essentially the same as running <strong>expectimax</strong> — we first compute the expected utility from each Q-state $(s, a)$ (equivalent to computing the value of chance nodes), then compute the maximum over these nodes to compute the maximum expected utility (equivalent to computing the value of a maximizer node).</p> <p>One final note on the Bellman equation — its usage is as a condition for optimality. In other words, if we can somehow determine a value $V(s)$ for every state $s \in S$ such that the Bellman equation holds true for each of these states, we can conclude that these values are the optimal values for their respective states. Indeed, satisfying this condition implies:</p> \[\forall s \in S, V(s) = V^*(s)\] <h2 id="value-iteration">Value Iteration</h2> <p>Now that we have a framework to test for the optimality of the values of states in an MDP, the natural follow-up question is how to actually compute these optimal values. To answer this, we need <strong>time-limited values</strong> (the natural result of enforcing finite horizons). The <strong>time-limited value</strong> for a state $s$ with a time limit of $k$ timesteps is denoted $V_k(s)$, and represents the maximum expected utility attainable from $s$ given that the Markov decision process under consideration terminates in $k$ timesteps. Equivalently, this is what a <strong>depth-$k$ expectimax</strong> run on the search tree for an MDP returns.</p> <p><strong>Value iteration</strong> is a dynamic programming algorithm that uses an iteratively longer time limit to compute time-limited values until convergence (that is, until the $V$ values are the same for each state as they were in the past iteration: $\forall s, V_{k+1}(s) = V_k(s)$). It operates as follows:</p> <ol> <li>$\forall s \in S, \text{ initialize } V_0(s) = 0$. This should be intuitive, since setting a time limit of 0 timesteps means no actions can be taken before termination, and so no rewards can be acquired.</li> <li>Repeat the following update rule until convergence: \(\forall s \in S, V_{k+1}(s) \leftarrow \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V_k(s') \right]\)</li> </ol> <p>At iteration $k$ of value iteration, we use the time-limited values with limit $k$ for each state to generate the time-limited values with limit $(k+1)$. In essence, we use computed solutions to subproblems (all the $V_k(s)$) to iteratively build up solutions to larger subproblems (all the $V_{k+1}(s)$); this is what makes value iteration a <strong>dynamic programming</strong> algorithm.</p> <p>Note that though the Bellman equation looks essentially identical to the update rule above, they are not the same. The Bellman equation gives a condition for optimality, while the update rule gives a method to iteratively update values until convergence. When convergence is reached, the Bellman equation will hold for every state: \(\forall s \in S, V_k(s) = V_{k+1}(s) = V^*(s)\)</p> <p>For conciseness, we frequently denote \(U_{k+1}(s) \leftarrow \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V_k(s') \right]\) with the shorthand $V_{k+1} \leftarrow B U_k$, where $B$ is called the <strong>Bellman operator</strong>. The Bellman operator is a contraction by $\gamma$. To prove this, we will need the following general inequality:</p> \[\vert \max_z f(z) - \max_z h(z) | \leq \max_z | f(z) - h(z) \vert\] <p>Now consider two value functions evaluated at the same state $V(s)$ and $V’(s)$. We show that the Bellman update $B$ is a contraction by $\gamma \in (0, 1)$ with respect to the max norm as follows:</p> \[| B V(s) - B V'(s) | = \left| \left( \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V(s') \right] \right) - \left( \max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V'(s') \right] \right) \right|\] \[\leq \max_a \left| \left( \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V(s') \right] \right) - \left( \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V'(s') \right] \right) \right|\] \[= \max_a \left| \gamma \sum_{s'} T(s, a, s') V(s') - \gamma \sum_{s'} T(s, a, s') V'(s') \right|\] \[= \gamma \max_a \left| \sum_{s'} T(s, a, s') (V(s') - V'(s')) \right|\] \[\leq \gamma \max_a \left| \sum_{s'} T(s, a, s') \max_{s'} | V(s') - V'(s') | \right|\] \[= \gamma \max_{s'} | V(s') - V'(s') |\] <p>Where the first inequality follows from the general inequality introduced above, the second inequality follows from taking the maximum of the differences between $V$ and $V’$, and in the second-to-last step, we use the fact that probabilities sum to 1 no matter the choice of $a$. The last step uses the definition of the max norm for a vector $x = (x_1, \dots, x_n)$, which is \(\Vert x\Vert_\infty = \max(|x_1|, \dots, |x_n|)\)</p> <p>Because we just proved that value iteration via Bellman updates is a contraction in $\gamma$, we know that value iteration converges, and convergence happens when we have reached a fixed point that satisfies \(V^* = B U^*\)</p> <p>Let’s see a few updates of value iteration in practice by revisiting our racecar MDP from earlier, introducing a discount factor of $\gamma=0.5$:</p> <center> <img src="https://anassbelcaid.github.io/course_ai/mdps/race-car.png" width="800" height="300" alt="Girl in a jacket"> </center> <p>In our first round of updates, we can compute $∀ s ∈ S, V_1(s)$ as follows:</p> <ul> <li>$V_1(\text{cool}) = \max \left\{ 1 \cdot \left[ 1 + 0.5 \cdot 0 \right], 0.5 \cdot \left[ 2 + 0.5 \cdot 0 \right] + 0.5 \cdot \left[ 2 + 0.5 \cdot 0 \right] \right\} = \max \{ 1, 2 \} = 2$</li> <li>$V_1(\text{warm}) = \max \left\{ 0.5 \cdot \left[ 1 + 0.5 \cdot 0 \right] + 0.5 \cdot \left[ 1 + 0.5 \cdot 0 \right], 1 \cdot \left[ -10 + 0.5 \cdot 0 \right] \right\} = \max \{ 1, -10 \} = 1$</li> <li>$V_1(\text{overheated}) = \max \left\{ \right\} = 0$</li> </ul> <table> <thead> <tr> <th> </th> <th>cool</th> <th>warm</th> <th>overheated</th> </tr> </thead> <tbody> <tr> <td>$U_0$</td> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>$U_1$</td> <td>2</td> <td>1</td> <td>0</td> </tr> </tbody> </table> <p>Similarly, we can repeat the procedure to compute a second round of updates with our newfound values for $U_1(s)$ to compute $V_2(s)$:</p> <ul> <li>$V_2(\text{cool}) = \max \left\{ 1 \cdot \left[ 1 + 0.5 \cdot 2 \right], 0.5 \cdot \left[ 2 + 0.5 \cdot 2 \right] + 0.5 \cdot \left[ 2 + 0.5 \cdot 1 \right] \right\} = \max \{ 2, 2.75 \} = 2.75$</li> <li>$V_2(\text{warm}) = \max \left\{ 0.5 \cdot \left[ 1 + 0.5 \cdot 2 \right] + 0.5 \cdot \left[ 1 + 0.5 \cdot 1 \right], 1 \cdot \left[ -10 + 0.5 \cdot 0 \right] \right\} = \max \{ 1.75, -10 \} = 1.75$</li> <li>$V_2(\text{overheated}) = \max \left\{ \right\} = 0$</li> </ul> <table> <thead> <tr> <th> </th> <th>cool</th> <th>warm</th> <th>overheated</th> </tr> </thead> <tbody> <tr> <td>$V_0$</td> <td>0</td> <td>0</td> <td>0</td> </tr> <tr> <td>$V_1$</td> <td>2</td> <td>1</td> <td>0</td> </tr> <tr> <td>$V_2$</td> <td>2.75</td> <td>1.75</td> <td>0</td> </tr> </tbody> </table> <p>It’s worthwhile to observe that $V^*(s)$ for any terminal state must be 0, since no actions can ever be taken from any terminal state to reap any rewards.</p> <h3 id="policy-extraction">Policy Extraction</h3> <p>Recall that our ultimate goal in solving an MDP is to determine an optimal policy. This can be done once all optimal values for states are determined using a method called policy extraction. The intuition behind policy extraction is very simple: if you’re in a state $s$, you should take the action $a$ which yields the maximum expected utility. Not surprisingly, $a$ is the action which takes us to the Q-state with maximum Q-value, allowing for a formal definition of the optimal policy:</p> \[\forall s ∈ S, \pi^*(s) = \arg\max_a Q^*(s, a) = \arg\max_a \sum_{s'} T(s, a, s') [R(s, a, s') + γV^*(s')]\] <p>It’s useful to keep in mind for performance reasons that it’s better for policy extraction to have the optimal Q-values of states, in which case a single $\arg\max$ operation is all that is required to determine the optimal action from a state. Storing only each $V^*(s)$ means that we must recompute all necessary Q-values with the Bellman equation before applying $\arg\max$, equivalent to performing a depth-1 expectimax.</p> <h3 id="q-value-iteration">Q-Value Iteration</h3> <p>In solving for an optimal policy using value iteration, we first find all the optimal values, then extract the policy using policy extraction. However, you might have noticed that we also deal with another type of value that encodes information about the optimal policy: Q-values.</p> <p>Q-value iteration is a dynamic programming algorithm that computes time-limited Q-values. It is described in the following equation:</p> \[Q_{k+1}(s, a) \leftarrow \sum_{s'} T(s, a, s') [R(s, a, s') + γ \max_{a'} Q_k(s', a')]\] <p>Note that this update is only a slight modification over the update rule for value iteration. Indeed, the only real difference is that the position of the $\max$ operator over actions has been changed since we select an action before transitioning when we’re in a state, but we transition before selecting a new action when we’re in a Q-state. Once we have the optimal Q-values for each state and action, we can then find the policy for a state by simply choosing the action which has the highest Q-value.</p> <h2 id="policy-iteration">Policy Iteration</h2> <p>Value iteration can be quite slow. At each iteration, we must update the values of all $\vert S\vert$ states (where $\vert S\vert $ refers to the cardinality operator), each of which requires iteration over all $\vert A \vert $ actions as we compute the Q-value for each action. The computation of each of these Q-values, in turn, requires iteration over each of the $\vert S\vert$ states again, leading to a poor runtime of $O(\vert S\vert^2 \vert A\vert)$. Additionally, when all we want to determine is the optimal policy for the MDP, value iteration tends to do a lot of overcomputation since the policy as computed by policy extraction generally converges significantly faster than the values themselves. The fix for these flaws is to use <strong>policy iteration</strong> as an alternative, an algorithm that maintains the optimality of value iteration while providing significant performance gains.</p> <p>Policy iteration operates as follows:</p> <ol> <li> <p><strong>Define an initial policy.</strong> This can be arbitrary, but policy iteration will converge faster the closer the initial policy is to the eventual optimal policy.</p> </li> <li> <p><strong>Repeat the following until convergence:</strong></p> <ul> <li> <strong>Evaluate the current policy with policy evaluation.</strong> For a policy $\pi$, policy evaluation means computing $V_{\pi}(s)$ for all states $s$, where $V_{\pi}(s)$ is the expected utility of starting in state $s$ when following $\pi$: \(V_{\pi}(s) = \sum_{s'} T(s, \pi(s), s') \left[ R(s, \pi(s), s') + \gamma V_{\pi}(s') \right]\)</li> <li> <p>Define the policy at iteration $i$ of policy iteration as $\pi_i$. Since we are fixing a single action for each state, we no longer need the $\max$ operator, which effectively leaves us with a system of $|S|$ equations generated by the above rule. Each $V_{\pi_i}(s)$ can then be computed by simply solving this system. Alternatively, we can also compute $V_{\pi_i}(s)$ by using the following update rule until convergence, just like in value iteration: \(V_{\pi_i}^{k+1}(s) \leftarrow \sum_{s'} T(s, \pi_i(s), s') \left[ R(s, \pi_i(s), s') + \gamma V_{\pi_i}^k(s') \right]\) However, this second method is typically slower in practice.</p> </li> <li> <p>Once we’ve evaluated the current policy, use <strong>policy improvement</strong> to generate a better policy. Policy improvement uses policy extraction on the values of states generated by policy evaluation to generate this new and improved policy: \(\pi_{i+1}(s) = \arg\max_a \sum_{s'} T(s, a, s') \left[ R(s, a, s') + \gamma V_{\pi_i}(s') \right]\)</p> </li> <li>If $\pi_{i+1} = \pi_i$, the algorithm has converged, and we can conclude that $\pi_{i+1} = \pi_i = \pi^*$.</li> </ul> </li> </ol> <p>Let’s run through our racecar example one last time (getting tired of it yet?) to see if we get the same policy using policy iteration as we did with value iteration. Recall that we were using a discount factor of $\gamma = 0.5$.</p> <center> <img src="https://anassbelcaid.github.io/course_ai/mdps/race-car.png" width="800" height="300" alt="Girl in a jacket"> </center> <p>We start with an initial policy of <strong>Always go slow</strong>:</p> <table> <thead> <tr> <th> </th> <th>cool</th> <th>warm</th> <th>overheated</th> </tr> </thead> <tbody> <tr> <td>π₀</td> <td>slow</td> <td>slow</td> <td>—</td> </tr> </tbody> </table> <p>Because terminal states have no outgoing actions, no policy can assign a value to one. Hence, it’s reasonable to disregard the state “overheated” from consideration as we have done, and simply assign $V_{\pi_i}(s) = 0$ for any terminal state $s$. The next step is to run a round of policy evaluation on $\pi_0$:</p> \[V_{\pi_0}(\text{cool}) = 1 \cdot [1 + 0.5 \cdot V_{\pi_0}(\text{cool})]\] \[V_{\pi_0}(\text{warm}) = 0.5 \cdot [1 + 0.5 \cdot V_{\pi_0}(\text{cool})] + 0.5 \cdot [1 + 0.5 \cdot V_{\pi_0}(\text{warm})]\] <p>Solving this system of equations for $V_{\pi_0}(\text{cool})$ and $V_{\pi_0}(\text{warm})$ yields:</p> <table> <thead> <tr> <th> </th> <th>cool</th> <th>warm</th> <th>overheated</th> </tr> </thead> <tbody> <tr> <td>$V_{\pi_0}$</td> <td>2</td> <td>2</td> <td>0</td> </tr> </tbody> </table> <p>We can now run <strong>policy extraction</strong> with these values:</p> \[\pi_1(\text{cool}) = \arg\max \left\{ \begin{array}{ll} \text{slow}: 1 \cdot [1 + 0.5 \cdot 2] \\ \text{fast}: 0.5 \cdot [2 + 0.5 \cdot 2] + 0.5 \cdot [2 + 0.5 \cdot 2] \end{array} \right\} = \arg\max \left\{ \begin{array}{ll} \text{slow}: 2 \\ \text{fast}: 3 \end{array} \right\} = \text{fast}\] \[\pi_1(\text{warm}) = \arg\max \left\{ \begin{array}{ll} \text{slow}: 0.5 \cdot [1 + 0.5 \cdot 2] + 0.5 \cdot [1 + 0.5 \cdot 2] \\ \text{fast}: 1 \cdot [-10 + 0.5 \cdot 0] \end{array} \right\} = \arg\max \left\{ \begin{array}{ll} \text{slow}: 2 \\ \text{fast}: -10 \end{array} \right\} = \text{slow}\] <p>Running policy iteration for a second round yields:</p> <ul> <li>$\pi_2(\text{cool}) = \text{fast}$</li> <li>$\pi_2(\text{warm}) = \text{slow}$</li> </ul> <p>Since this is the same policy as $\pi_1$, we can conclude that $\pi_1 = \pi_2 = \pi^*$. Verify this for practice!</p> <table> <thead> <tr> <th> </th> <th>cool</th> <th>warm</th> </tr> </thead> <tbody> <tr> <td>π₀</td> <td>slow</td> <td>slow</td> </tr> <tr> <td>π₁</td> <td>fast</td> <td>slow</td> </tr> <tr> <td>π₂</td> <td>fast</td> <td>slow</td> </tr> </tbody> </table> <p>This example shows the true power of policy iteration: with only two iterations, we’ve already arrived at the optimal policy for our racecar MDP! This is more than we can say for when we ran value iteration on the same MDP, which was still several iterations from convergence after the two updates we performed.</p> <h2 id="summary">Summary</h2> <p>The material presented above has much opportunity for confusion. We covered <strong>value iteration</strong>, <strong>policy iteration</strong>, <strong>policy extraction</strong>, and <strong>policy evaluation</strong>, all of which look similar, using the Bellman equation with subtle variations.</p> <p>Below is a summary of the purpose of each algorithm:</p> <ul> <li> <strong>Value iteration</strong>: Used for computing the optimal values of states, by iterative updates until convergence.</li> <li> <strong>Policy evaluation</strong>: Used for computing the values of states under a specific policy.</li> <li> <strong>Policy extraction</strong>: Used for determining a policy given some state value function. If the state values are optimal, this policy will be optimal. This method is used after running value iteration to compute an optimal policy from the optimal state values, or as a subroutine in policy iteration to compute the best policy for the currently estimated state values.</li> <li> <strong>Policy iteration</strong>: A technique that encapsulates both policy evaluation and policy extraction and is used for iterative convergence to an optimal policy. It tends to outperform value iteration by virtue of the fact that policies usually converge much faster than the values of states.</li> </ul> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/course_ai/assets/bibliography/2018-12-22-distill.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Anass Dr. Belcaid. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/chartjs-setup.js?183c5859923724fb1cb3c67593848e71" type="text/javascript"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/echarts-setup.js?738178999630746a8d0cfc261fc47c2c" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/vega-setup.js?7c7bee055efe9312afc861b128fe5f36" type="text/javascript"></script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/typograms.js?062e75bede72543443762dc3fe36c7a5"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/course_ai/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/course_ai/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/course_ai/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/course_ai/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/course_ai/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/course_ai/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/course_ai/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>